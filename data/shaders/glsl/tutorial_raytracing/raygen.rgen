#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_ARB_shader_clock : enable

// This is needed to support buffer_reference extension
// We need buffer_reference to be able to store multiple Model structs
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require

#include "sampling.glsl"
#include "rayTracingInputOutput.h"

layout(location = 0) rayPayloadEXT HitPayload payLoad;

void main() 
{
	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
	vec2 d = inUV * 2.0 - 1.0;

	vec4 rayOrigin = sceneUbo.viewMatrixInverse * vec4(0,0,0,1);
	vec4 target = sceneUbo.projectionMatrixInverse * vec4(d.x, d.y, 1, 1) ;
	vec4 rayDirection = sceneUbo.viewMatrixInverse*vec4(normalize(target.xyz), 0) ;

	float tmin = 0.001;
	float tmax = 10000.0;

	if (pushConstants.pathTracer > 0)
	{
		uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, int(clockARB()));

		payLoad.hitValue = vec3(0.0);
		payLoad.seed = seed;
		payLoad.rayOrigin = rayOrigin.xyz;
		payLoad.rayDirection = rayDirection.xyz;
		payLoad.depth = 0;
		payLoad.weight = vec3(0.0);

		vec3 throughput = vec3(1);
		vec3 radiance  = vec3(0);

		for(; payLoad.depth < 10; payLoad.depth++)
		{
			traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, payLoad.rayOrigin, tmin, payLoad.rayDirection, tmax, 0);

			radiance += payLoad.hitValue * throughput;
			throughput *= payLoad.weight;
		}

		vec4 valueToWrite = vec4(0,0,0,0);
		// do all computations at 32 bit resolution
		if (pushConstants.frameIndex > 0)
		{
			float a         = 1.0f / float(pushConstants.frameIndex + 1);
			vec3  oldColor = imageLoad(intermediateImage, ivec2(gl_LaunchIDEXT.xy)).xyz;

			valueToWrite = vec4(mix(oldColor, radiance, a), 1.f);
			imageStore(intermediateImage, ivec2(gl_LaunchIDEXT.xy),valueToWrite );
		}
		else
		{
			valueToWrite = vec4(radiance, 0.0);
			imageStore(intermediateImage, ivec2(gl_LaunchIDEXT.xy), valueToWrite);
		}

		// write the final value to the 8 bit resolution after tonemapping, etc
		float one_by_gamma = 1.0/2.2f;
		valueToWrite = pow(valueToWrite, vec4(one_by_gamma));
		imageStore(finalImage, ivec2(gl_LaunchIDEXT.xy), valueToWrite);
	}
	else
	{
		payLoad.hitValue = vec3(0.0);
		payLoad.seed = 0;
		payLoad.rayOrigin = rayOrigin.xyz;
		payLoad.rayDirection = rayDirection.xyz;
		payLoad.depth = 0;
		payLoad.weight = vec3(0.0);

		traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, payLoad.rayOrigin, tmin, payLoad.rayDirection, tmax, 0);
		imageStore(finalImage, ivec2(gl_LaunchIDEXT.xy), vec4(payLoad.hitValue, 0.0));
	}
}
